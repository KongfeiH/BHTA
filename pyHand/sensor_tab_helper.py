#  sensor_tab_helper.py
#  
#  ~~~~~~~~~~~~
#  
#  pyHand Sensor Tab Helper File
#  
#  ~~~~~~~~~~~~
#  
#  ------------------------------------------------------------------
#  Authors : Chloe Eghtebas,
#            Brendan Ritter,
#            Pravina Samaratunga
#            Jason Schwartz
#  
#  Last change: 08.08.2013
#
#  Language: Python 2.7
#  ------------------------------------------------------------------
# 
#  This version of pyHand is free software: you can redistribute it and/or 
#  modify it under the terms of the GNU General Public License as published
#  by the Free Software Foundation.
#

from pyHand_API.pyHand_api import *

class HandSensor:
    '''
    HandSensor Object: Holds the tactile data of the fingers in an array or dictionary.
    
        @cvar finger1: Tactile Data for finger 1.
        @ctype finger1: Array or Dictionary
        @cvar finger2: Tactile Data for finger 2.
        @ctype finger2: Array or Dictionary
        @cvar finger3: Tactile Data for finger 3.
        @ctype finger3: Array or Dictionary
        @cvar spread: Tactile Data for palm.
        @ctype spread: Array or Dictionary
    '''
    
    def __init__(self):
        '''
        Initializes the HandSensor object with full tactile data.
        '''
        self.finger1 = []
        self.finger2 = []
        self.finger3 = []
        self.spread = []
        can_reset()
        self.get_full_tact()
    
    def get_full_tact(self):
        '''
        This method will get all data from the hand and sort it into proper data frames.
        '''
        self.finger1 = range(24)
        self.finger2 = range(24)
        self.finger3 = range(24)
        self.spread = range(24)
        # Read all 20 CAN frames for the tactile data.
        can_frames = []
        write_msg(FINGER1, [TACT+0x80, 0, TACT_FULL, 0])
        r = read_msg()
        while r[0] == PCAN_ERROR_OK:
            can_frames.append(r[1])
            r = read_msg()
        write_msg(FINGER2, [TACT+0x80, 0, TACT_FULL, 0])
        r = read_msg()
        while r[0] == PCAN_ERROR_OK:
            can_frames.append(r[1])
            r = read_msg()
        write_msg(FINGER3, [TACT+0x80, 0, TACT_FULL, 0])
        r = read_msg()
        while r[0] == PCAN_ERROR_OK:
            can_frames.append(r[1])
            r = read_msg()
        write_msg(SPREAD, [TACT+0x80, 0, TACT_FULL, 0])
        r = read_msg()
        while r[0] == PCAN_ERROR_OK:
            can_frames.append(r[1])
            r = read_msg()
        
        # Interpret these messages
        for frame in can_frames:
            if frame.ID == 0x569: # Full tact from finger 1
                self.populate_array_part_full(self.finger1, frame)
            if frame.ID == 0x589: # Full tact from Finger 2
                self.populate_array_part_full(self.finger2, frame)
            if frame.ID == 0x5A9: # Full tact From finger 3
                self.populate_array_part_full(self.finger3, frame)
            if frame.ID == 0x5C9: # Full tact From spread
                self.populate_array_part_full(self.spread, frame)
    
    def populate_array_part_full(self, tact_array, frame):
        '''
        Sets the finger specified to hold full tactile data.

            @param tact_array: The array that will hold the full tactile array data that has been generated by the CAN.
            @param frame: The CAN frame to be unpacked.
        '''
        data = frame.DATA
        index = int(data[0]/16) * 5
        # Get the bits and then unpack them.
        tact_array[index + 0] = round(((data[0]%0x10)*0x100 + data[1])/256.0,2)
        tact_array[index + 1] = round((data[2]*0x10 + int(data[3]/0x10))/256.0,2)
        tact_array[index + 2] = round(((data[3]%0x10)*0x100 + data[4])/256.0,2)
        tact_array[index + 3] = round((data[5]*0x10 + int(data[6]/0x10))/256.0,2)
        if index != 20:
            tact_array[index + 4] = round(((data[6]%0x10)*0x100 + data[7])/256.0,2)

    def get_top10_tact(self):
        '''
        Get the 10 highest values from the tactile sensors from each puck.
        NOTE: This function may or may not work. Implement at your own risk.
        '''
        #This function may or may not work. Implement at your own risk.
        self.finger1 = {}
        self.finger2 = {}
        self.finger3 = {}
        self.spread = {}

        can_frames = []
        write_msg(FINGER1, [TACT+0x80, 0, TACT_10, 0])
        r = read_msg()
        while r[0] == PCAN_ERROR_OK:
            can_frames.append(r[1])
            r = read_msg()
        write_msg(FINGER2, [TACT+0x80, 0, TACT_10, 0])
        r = read_msg()
        while r[0] == PCAN_ERROR_OK:
            can_frames.append(r[1])
            r = read_msg()
        write_msg(FINGER3, [TACT+0x80, 0, TACT_10, 0])
        r = read_msg()
        while r[0] == PCAN_ERROR_OK:
            can_frames.append(r[1])
            r = read_msg()
        write_msg(SPREAD, [TACT+0x80, 0, TACT_10, 0])
        r = read_msg()
        while r[0] == PCAN_ERROR_OK:
            can_frames.append(r[1])
            r = read_msg()

        # Interpret these messages
        for frame in can_frames:
            if frame.ID == 0x568: # Top 10 tact from finger 1
                self.populate_array_part_top10(self.finger1, frame)
            if frame.ID == 0x588: # Top 10 tact from Finger 2
                self.populate_array_part_top10(self.finger2, frame)
            if frame.ID == 0x5A8: # Top 10 tact From finger 3
                self.populate_array_part_top10(self.finger3, frame)
            if frame.ID == 0x5C8: # Top 10 tact From spread
                self.populate_array_part_top10(self.spread, frame)

    def populate_array_part_top10(self, tact_array, frame):
        '''
        Sets the finger specified to hold top 10 tactile data.
        NOTE: This function may or may not work, implement at your own risk.

            @param tact_array: The array that will hold the full tactile array data that has been generated by the CAN.
            @param frame: The CAN frame to be unpacked.
        '''
        data = frame.DATA
        topVals = []
        for i in range(8):
            for byte in range[3]:
                if int(data[byte]/2**i)%2 > 0:
                    topVals.append[8*(3-byte)-i]
        top10 = {}
        for i in range(5):
            top10[topVals[2*i]] = data[i+3]/16
            top10[topVals[2*i+1]]= data[i+3]%16
        return top10

    def tare(self, puckID):
        '''
        Tare the tactile sensors.

            @param puckID: The finger whose sensors are to be tared.
        '''
        set_property(puckID, TACT, 3)



